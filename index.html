<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leet Code Problems</title>
  </head>
  <body>
    <ol type="1">
      <li>
        Two Sum: Given an array of integers nums and an integer target, return
        indices of the two numbers such that they add up to target.
        <br />
        <code
          >Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation:
          Because nums[0] + nums[1] == 9, we return [0, 1].</code
        >
      </li>
      <li>
        Given a non-empty array of integers nums, every element appears twice
        except for one. Find that single one. You must implement a solution with
        a linear runtime complexity and use only constant extra space.
        <br />
        <code>Input: nums = [2,2,1] Output: 1</code>
      </li>
      <li>
        You are given an m x n integer matrix matrix with the following two
        properties: Each row is sorted in non-decreasing order. The first
        integer of each row is greater than the last integer of the previous
        row. Given an integer target, return true if target is in matrix or
        false otherwise. You must write a solution in O(log(m * n)) time
        complexity.
      </li>
      <li>
        Given a multi-dimensional array of integers, return a generator object
        which yields integers in the same order as inorder traversal. A
        multi-dimensional array is a recursive data structure that contains both
        integers and other multi-dimensional arrays. inorder traversal iterates
        over each array from left to right, yielding any integers it encounters
        or applying inorder traversal to any arrays it encounters. Example 1:
        <br />
        <code
          >Input: arr = [[[6]],[1,3],[]] Output: [6,1,3] Explanation: const
          generator = inorderTraversal(arr); generator.next().value; // 6
          generator.next().value; // 1 generator.next().value; // 3
          generator.next().done; // true Example 2: Input: arr = [] Output: []
          Explanation: There are no integers so the generator doesn't yield
          anything.</code
        >
      </li>
      <li>
        Given two promises promise1 and promise2, return a new promise. promise1
        and promise2 will both resolve with a number. The returned promise
        should resolve with the sum of the two numbers.
        <br />
        <code>
          Input: promise1 = new Promise(resolve => setTimeout(() => resolve(2),
          20)), promise2 = new Promise(resolve => setTimeout(() => resolve(5),
          60)) Output: 7 Explanation: The two input promises resolve with the
          values of 2 and 5 respectively. The returned promise should resolve
          with a value of 2 + 5 = 7. The time the returned promise resolves is
          not judged for this problem.
        </code>
      </li>
      <li>
        Write a function createCounter. It should accept an initial integer
        init. It should return an object with three functions. The three
        functions are:
        <br />
        <code>
          increment() increases the current value by 1 and then returns it.
          decrement() reduces the current value by 1 and then returns it.
          reset() sets the current value to init and then returns it.
        </code>
      </li>
      <li>
        Given an array arr and a chunk size size, return a chunked array. A
        chunked array contains the original elements in arr, but consists of
        subarrays each of length size. The length of the last subarray may be
        less than size if arr.length is not evenly divisible by size. You may
        assume the array is the output of JSON.parse. In other words, it is
        valid JSON.
      </li>
      <br />
      <code>
        Example 1: Input: arr = [1,2,3,4,5], size = 1 Output:
        [[1],[2],[3],[4],[5]] Explanation: The arr has been split into subarrays
        each with 1 element. Example 2: Input: arr = [1,9,6,3,2], size = 3
        Output: [[1,9,6],[3,2]] Explanation: The arr has been split into
        subarrays with 3 elements. However, only two elements are left for the
        2nd subarray. Example 3: Input: arr = [8,5,3,2,6], size = 6 Output:
        [[8,5,3,2,6]] Explanation: Size is greater than arr.length thus all
        elements are in the first subarray. Example 4: Input: arr = [], size = 1
        Output: [] Explanation: There are no elements to be chunked so an empty
        array is returned.
      </code>
    </ol>
    <script src="./code/li-1.js"></script>
    <script src="./code/li-2.js"></script>
    <script src="./code/li-3.js"></script>
    <script src="./code/li-4.js"></script>
    <script src="./code/li-5.js"></script>
  </body>
</html>
